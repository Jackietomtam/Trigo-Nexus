# 图表直线问题修复总结

## 📋 问题描述

在Edition 2页面中，AI模型的账户价值图表在运行一段时间后会变成一条水平直线，不再更新。

## 🔍 问题根因分析

经过代码审查，发现了**两个关键问题**：

### 问题1: 历史数据不实时更新

**位置**: `static/js/app.js`

**问题**:
- 图表历史数据只在页面初次加载时调用 `/api/history` 获取一次
- 之后虽然通过WebSocket接收实时更新，但更新数据中**不包含历史数据**
- 导致图表数据停留在初始加载时的状态，随着时间推移，新的数据点没有添加，图表看起来像一条直线

**代码片段**:
```javascript
// loadAll() 只在页面加载时调用一次
async loadAll() {
    const [priceData, lb, trades, chats, hist] = await Promise.all([
        this.api('/api/prices'),
        this.api('/api/leaderboard'),
        this.api('/api/trades'),
        this.api('/api/chat'),
        this.api('/api/history')  // ← 只调用一次
    ]);
    this.updateChart(hist);
}

// onUpdate() 处理WebSocket更新，但没有history字段
onUpdate(d) {
    if (d.prices) this.updateTicker(d.prices, d.changes);
    if (d.leaderboard) this.updateCards(d.leaderboard);
    if (d.history) this.updateChart(d.history);  // ← d.history始终为空
}
```

### 问题2: WebSocket事件名称不匹配

**位置**: `static/js/app.js` 和 `app_dual_edition.py`

**问题**:
- 前端监听的是 `market_update` 事件
- 后端发送的是 `edition1_update` 和 `edition2_update` 事件
- 导致前端根本**收不到**任何实时更新

**代码片段**:
```javascript
// 前端 (app.js)
initSocket() {
    this.socket = io();
    this.socket.on('market_update', (d) => this.onUpdate(d));  // ← 监听错误的事件名
}
```

```python
# 后端 (app_dual_edition.py)
# Edition 1 交易循环
socketio.emit('edition1_update', {  # ← 发送的事件名不匹配
    'prices': current_prices,
    'leaderboard': leverage_engine_e1.get_leaderboard(),
    'stats': competition_stats_e1
}, namespace='/')

# Edition 2 交易循环
socketio.emit('edition2_update', {  # ← 发送的事件名不匹配
    'prices': current_prices,
    'leaderboard': leverage_engine_e2.get_leaderboard(),
    'stats': competition_stats_e2
}, namespace='/')
```

## ✅ 解决方案

### 修复1: 添加定期更新历史数据的机制

在 `static/js/app.js` 的 `init()` 方法中添加定时器，每30秒更新一次历史数据：

```javascript
init() {
    this.initSocket();
    this.initChart();
    this.setupEvents();
    this.loadAll();
    
    // 定期更新历史数据（每30秒更新一次图表）
    setInterval(() => {
        this.api('/api/history').then(hist => {
            if (hist) this.updateChart(hist);
        }).catch(e => console.error('更新历史数据失败:', e));
    }, 30000);
}
```

**优点**:
- 图表数据会每30秒自动刷新
- 不会增加WebSocket的传输负担
- 确保图表始终显示最新的历史数据

### 修复2: 修复WebSocket事件监听

修改 `initSocket()` 方法，根据当前页面监听正确的事件：

```javascript
initSocket() {
    this.socket = io();
    this.socket.on('connect', () => console.log('✓ 已连接'));
    
    // 根据当前页面监听对应的事件
    const currentPath = window.location.pathname;
    if (currentPath.includes('/edition1')) {
        this.socket.on('edition1_update', (d) => this.onUpdate(d));
        console.log('监听 edition1_update 事件');
    } else if (currentPath.includes('/edition2')) {
        this.socket.on('edition2_update', (d) => this.onUpdate(d));
        console.log('监听 edition2_update 事件');
    } else {
        // 默认监听两个事件
        this.socket.on('edition1_update', (d) => this.onUpdate(d));
        this.socket.on('edition2_update', (d) => this.onUpdate(d));
    }
    
    // 兼容旧的 market_update 事件
    this.socket.on('market_update', (d) => this.onUpdate(d));
}
```

**优点**:
- 正确监听后端发送的事件
- 价格、排行榜等数据可以实时更新
- 保持向后兼容性

## 🎯 预期效果

修复后：
1. ✅ 图表会每30秒自动更新，显示最新的账户价值变化
2. ✅ 价格、排行榜、持仓等数据通过WebSocket实时更新
3. ✅ 不再出现"直线"问题
4. ✅ 两个版本(Edition 1和Edition 2)都能正常工作

## 📝 测试步骤

1. 清除浏览器缓存（强制刷新：Cmd+Shift+R）
2. 访问 https://trigonexus.us/edition2
3. 观察图表是否随时间更新
4. 打开浏览器控制台，查看是否有 "监听 edition2_update 事件" 的日志
5. 等待30秒，确认图表是否更新

## 🔧 技术细节

### 为什么选择30秒更新间隔？

- **性能考虑**: 历史数据量较大，频繁请求会增加服务器负担
- **用户体验**: 30秒的间隔足够显示账户价值的变化趋势
- **网络优化**: 减少不必要的网络请求

### 为什么不在WebSocket中发送历史数据？

- **数据量**: 历史数据可能包含数千个数据点，每次更新都发送会浪费带宽
- **效率**: WebSocket适合发送小而频繁的更新（如价格、持仓）
- **架构**: 分离关注点——WebSocket负责实时数据，HTTP轮询负责历史数据

## 📅 修复日期

2025-10-28

## 👨‍💻 修复人员

AI Assistant (Claude Sonnet 4.5)

